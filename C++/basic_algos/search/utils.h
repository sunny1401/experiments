# include <unordered_map>
# include <vector>
# include <set>
# include <string>
# include <algorithm>
# include <fstream>

// populated stop words from python spacy
std::set<std::string> stop_words = {
"'d",
 "'ll",
 "'m",
 "'re",
 "'s",
 "'ve",
 "a",
 "about",
 "above",
 "across",
 "after",
 "afterwards",
 "again",
 "against",
 "all",
 "almost",
 "alone",
 "along",
 "already",
 "also",
 "although",
 "always",
 "am",
 "among",
 "amongst",
 "amount",
 "an",
 "and",
 "another",
 "any",
 "anyhow",
 "anyone",
 "anything",
 "anyway",
 "anywhere",
 "are",
 "around",
 "as",
 "at",
 "back",
 "be",
 "became",
 "because",
 "become",
 "becomes",
 "becoming",
 "been",
 "before",
 "beforehand",
 "behind",
 "being",
 "below",
 "beside",
 "besides",
 "between",
 "beyond",
 "both",
 "bottom",
 "but",
 "by",
 "ca",
 "call",
 "can",
 "cannot",
 "could",
 "did",
 "do",
 "does",
 "doing",
 "done",
 "down",
 "due",
 "during",
 "each",
 "eight",
 "either",
 "eleven",
 "else",
 "elsewhere",
 "empty",
 "enough",
 "even",
 "ever",
 "every",
 "everyone",
 "everything",
 "everywhere",
 "except",
 "few",
 "fifteen",
 "fifty",
 "first",
 "five",
 "for",
 "former",
 "formerly",
 "forty",
 "four",
 "from",
 "front",
 "full",
 "further",
 "get",
 "give",
 "go",
 "good",
 "had",
 "has",
 "have",
 "he",
 "hence",
 "her",
 "here",
 "hereafter",
 "hereby",
 "herein",
 "hereupon",
 "hers",
 "herself",
 "him",
 "himself",
 "his",
 "how",
 "however",
 "hundred",
 "i",
 "if",
 "in",
 "indeed",
 "into",
 "is",
 "it",
 "its",
 "itself",
 "just",
 "keep",
 "last",
 "latter",
 "latterly",
 "least",
 "less",
 "like",
 "love",
 "made",
 "make",
 "many",
 "may",
 "me",
 "meanwhile",
 "might",
 "mine",
 "more",
 "moreover",
 "most",
 "mostly",
 "move",
 "much",
 "must",
 "my",
 "myself",
 "n't",
 "name",
 "namely",
 "neither",
 "never",
 "nevertheless",
 "next",
 "nice",
 "nine",
 "no",
 "nobody",
 "none",
 "noone",
 "nor",
 "not",
 "nothing",
 "now",
 "nowhere",
 "n‘t",
 "n’t",
 "of",
 "off",
 "often",
 "on",
 "once",
 "one",
 "only",
 "onto",
 "or",
 "other",
 "others",
 "otherwise",
 "our",
 "ours",
 "ourselves",
 "out",
 "over",
 "own",
 "part",
 "per",
 "perhaps",
 "please",
 "put",
 "quite",
 "rather",
 "re",
 "really",
 "regarding",
 "same",
 "say",
 "see",
 "seem",
 "seemed",
 "seeming",
 "seems",
 "serious",
 "several",
 "she",
 "should",
 "show",
 "side",
 "since",
 "six",
 "sixty",
 "so",
 "some",
 "somehow",
 "someone",
 "something",
 "sometime",
 "sometimes",
 "somewhere",
 "still",
 "such",
 "take",
 "tell",
 "ten",
 "than",
 "that",
 "the",
 "their",
 "them",
 "themselves",
 "then",
 "thence",
 "there",
 "thereafter",
 "thereby",
 "therefore",
 "therein",
 "thereupon",
 "these",
 "they",
 "third",
 "this",
 "those",
 "though",
 "three",
 "through",
 "throughout",
 "thru",
 "thus",
 "to",
 "together",
 "too",
 "top",
 "toward",
 "towards",
 "twelve",
 "twenty",
 "two",
 "u",
 "under",
 "unless",
 "until",
 "up",
 "upon",
 "us",
 "used",
 "using",
 "various",
 "very",
 "via",
 "was",
 "we",
 "well",
 "were",
 "what",
 "whatever",
 "when",
 "whence",
 "whenever",
 "where",
 "whereafter",
 "whereas",
 "whereby",
 "wherein",
 "whereupon",
 "wherever",
 "whether",
 "which",
 "while",
 "whither",
 "who",
 "whoever",
 "whole",
 "whom",
 "whose",
 "why",
 "will",
 "with",
 "within",
 "without",
 "would",
 "yet",
 "you",
 "your",
 "yours",
 "yourself",
 "yourselves"
};

std::unordered_map<std::string, int> get_words_from_file(std::string input_file){

    int count = 0;
    std::string line;
    std::unordered_map<std::string, int> input_data;
    std::ifstream inp_file (input_file);
    if (inp_file.is_open()){
        while(getline (inp_file, line)){
            input_data[line] = count;
            count += 1;
        }
    }
    else{
        std::cerr << "Invalid argument: " << input_file << "does not exists \n";
    }
    return input_data;
}


std::vector<std::string> get_match(std::string input_string){
    
    std::vector<std::string> input_words;
    std::istringstream ss(input_string);
    std:: string word;
    
    while (ss >> word) 
    {
        if (stop_words.find(word) == stop_words.end())
        {
            std::transform(word.begin(), word.end(), word.begin(), ::tolower);
            input_words.push_back(word);
        }
    }
    return input_words;

}